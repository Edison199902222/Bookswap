




给出一个序列，明确要求分割成K个连续区间，要你计算这些区间的某个最优性质。
状态定义：dp[i][k]表示针对s[1:i]分成k个区间，此时能够得到的最优解
从后往前找j/ 从前往后找都行，取决于哪一个更方便
搜寻最后一个区间的起始位置j，将dp[i][k]分割成dp[j-1][k-1]和s[j:i]两部分。
最终的结果是dp[N][K]

for (int i=1; i<=n; i++)
    for (int k=1; k<=min(i,K); k++) # 保证当前最多能取几个区间
      	{
      	    for (int j=i; j>=k; j--) # 保证前面的元素 可以构成k - 1 个区间
             {
                dp[i][k] = min(dp[i][k],
 			  dp[j-1][k-1] + count[j:i]);
              }
       }

一定要考虑边界条件 dp[0][0], dp[x][0]
第一层循环遍历i
第二层循环遍历k
第三层循环寻找最优的位置j作为最后一个分区的起始位置。
将dp[i][k]分割成dp[j-1][k-1]和s[j:i]求解
